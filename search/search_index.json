{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LangZ","text":"<p>A scripting language that transpiles to Bash, designed for DevOps, SRE, and system administration tasks.</p> <p>Write clean, readable scripts and compile them to portable Bash that runs anywhere.</p> <p>Note</p> <p>This project was entirely created by an LLM (Claude by Anthropic), including the language design, compiler, LSP server, VS Code extension, tests, and documentation.</p>"},{"location":"#why-langz","title":"Why LangZ?","text":"<p>Bash is powerful but hard to read and write correctly. LangZ gives you:</p> <ul> <li>Clean syntax -- no <code>$</code>, <code>fi</code>, <code>esac</code>, or quoting headaches</li> <li>String interpolation -- <code>\"Hello {name}\"</code> instead of <code>\"Hello $name\"</code></li> <li>Built-in DevOps functions -- file ops, system info, HTTP requests, JSON parsing</li> <li>Safe defaults -- generates <code>set -euo pipefail</code> automatically</li> <li>Zero runtime -- compiles to plain Bash, nothing to install on target</li> <li>Imports -- split code across files with <code>import \"lib.lz\"</code></li> <li>Bash escape hatch -- embed raw shell with <code>bash { ... }</code> when needed</li> <li>Shebang support -- <code>#!/usr/bin/env langz</code> for directly executable scripts</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>app = \"webapp\"\nenv_name = env(\"DEPLOY_ENV\") or \"staging\"\n\nfn log(msg: str) {\n    print(\"[deploy] {msg}\")\n}\n\nlog(\"Deploying {app} to {env_name}\")\n\nmkdir(\"dist\")\nwrite(\"dist/version.txt\", \"1.0.0\")\n\nif exists(\"config.json\") {\n    copy(\"config.json\", \"dist/config.json\")\n} else {\n    log(\"No config, using defaults\")\n}\n</code></pre> <p>This compiles to clean, portable Bash with <code>set -euo pipefail</code>, proper quoting, and standard shell idioms.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started -- install and write your first script</li> <li>Language Guide -- learn the syntax</li> <li>Builtins Reference -- all built-in functions</li> <li>Examples -- real-world scripts</li> </ul>"},{"location":"builtins/","title":"Builtins Reference","text":"<p>All built-in functions available in LangZ.</p>"},{"location":"builtins/#io","title":"I/O","text":"Function Description Bash <code>print(args...)</code> Print to stdout <code>echo args</code> <code>read(path)</code> Read file contents <code>$(cat path)</code> <code>write(path, content)</code> Write to file <code>echo content &gt; path</code> <code>append(path, content)</code> Append to file <code>echo content &gt;&gt; path</code>"},{"location":"builtins/#file-operations","title":"File Operations","text":"Function Description Bash <code>exists(path)</code> Check if path exists <code>[ -e path ]</code> <code>is_file(path)</code> Check if file <code>[ -f path ]</code> <code>is_dir(path)</code> Check if directory <code>[ -d path ]</code> <code>mkdir(path)</code> Create directory (with parents) <code>mkdir -p path</code> <code>rm(path)</code> Remove file <code>rm -f path</code> <code>rmdir(path)</code> Remove directory recursively <code>rm -rf path</code> <code>copy(src, dst)</code> Copy file <code>cp src dst</code> <code>move(src, dst)</code> Move/rename file <code>mv src dst</code> <code>chmod(path, mode)</code> Change permissions <code>chmod mode path</code> <code>chown(path, owner)</code> Change owner <code>chown owner path</code> <code>glob(pattern)</code> Expand glob pattern <code>(pattern)</code>"},{"location":"builtins/#system","title":"System","text":"Function Description Bash <code>exec(cmd)</code> Run shell command <code>$(cmd)</code> <code>env(name)</code> Get environment variable <code>\"${NAME}\"</code> <code>os()</code> Get OS name (lowercase) <code>$(uname -s \\| tr ...)</code> <code>arch()</code> Get CPU architecture <code>$(uname -m)</code> <code>hostname()</code> Get hostname <code>$(hostname)</code> <code>whoami()</code> Get current user <code>$(whoami)</code> <code>sleep(n)</code> Sleep n seconds <code>sleep n</code> <code>exit(code)</code> Exit with status code <code>exit code</code> <code>args()</code> Get script arguments <code>(\"$@\")</code>"},{"location":"builtins/#string-path","title":"String &amp; Path","text":"Function Description Bash <code>upper(s)</code> Convert to uppercase <code>$(echo s \\| tr ...)</code> <code>lower(s)</code> Convert to lowercase <code>$(echo s \\| tr ...)</code> <code>trim(s)</code> Trim whitespace <code>$(echo s \\| xargs)</code> <code>len(list)</code> Get list length <code>${#list[@]}</code> <code>dirname(path)</code> Directory part of path <code>$(dirname path)</code> <code>basename(path)</code> Filename part of path <code>$(basename path)</code> <code>range(start, end)</code> Generate number sequence <code>$(seq start end)</code>"},{"location":"builtins/#string-methods","title":"String Methods","text":"<p>Methods called on string variables:</p> Method Description Bash <code>s.replace(old, new)</code> Replace all occurrences <code>\"${s//old/new}\"</code> <code>s.contains(substr)</code> Check if string contains substr <code>[[ \"$s\" == *\"substr\"* ]]</code> <code>s.starts_with(prefix)</code> Check if string starts with prefix <code>[[ \"$s\" == \"prefix\"* ]]</code> <code>s.ends_with(suffix)</code> Check if string ends with suffix <code>[[ \"$s\" == *\"suffix\" ]]</code> <code>s.split(sep)</code> Split string into array <code>IFS='sep' read -ra arr &lt;&lt;&lt; \"$s\"</code> <code>s.join(sep)</code> Join array elements <code>$(IFS='sep'; echo \"${s[*]}\")</code> <code>s.length()</code> Get string length <code>${#s}</code> <p><code>.contains()</code>, <code>.starts_with()</code>, and <code>.ends_with()</code> return conditions for use in <code>if</code>/<code>while</code>. <code>.split()</code> produces an array that can be indexed:</p> <pre><code>name = \"hello world\"\nresult = name.replace(\"world\", \"langz\")\n\nif name.contains(\"hello\") {\n    print(\"found\")\n}\n\ncsv = \"alice,bob,charlie\"\nparts = csv.split(\",\")\nprint(parts[1])  // \"bob\"\n\nitems = [\"a\", \"b\", \"c\"]\njoined = items.join(\"-\")  // \"a-b-c\"\n\nn = name.length()  // 11\n</code></pre>"},{"location":"builtins/#networking","title":"Networking","text":"Function Description <code>fetch(url, ...)</code> HTTP request via curl (details) <code>json_get(data, path)</code> Extract JSON value via jq"},{"location":"builtins/#fetch-keyword-arguments","title":"fetch() Keyword Arguments","text":"Kwarg Description Default <code>method:</code> HTTP method GET <code>body:</code> Request body none <code>headers:</code> Headers map none <code>timeout:</code> Timeout in seconds none <code>retries:</code> Retry count none <p>Sets convention variables: <code>_status</code>, <code>_body</code>, <code>_headers</code>.</p>"},{"location":"builtins/#datetime","title":"Date/Time","text":"Function Description Bash <code>timestamp()</code> Unix timestamp <code>$(date +%s)</code> <code>date()</code> Current date (YYYY-MM-DD) <code>$(date +\"%Y-%m-%d\")</code>"},{"location":"editor-support/","title":"Editor Support","text":"<p>LangZ includes a built-in Language Server Protocol (LSP) server for rich editor integration.</p>"},{"location":"editor-support/#features","title":"Features","text":"Feature Description Diagnostics Real-time parse error highlighting Hover Documentation for builtins and keyword arguments Completion Builtins, keywords, user symbols, and context-aware kwargs Signature Help Parameter hints when typing function calls Go-to-Definition Jump to variable and function definitions Document Symbols Outline view of variables and functions Formatting Auto-format <code>.lz</code> files"},{"location":"editor-support/#vs-code-extension","title":"VS Code Extension","text":"<p>A VS Code extension is included in the <code>editors/vscode/</code> directory.</p>"},{"location":"editor-support/#install-from-source","title":"Install from Source","text":"<pre><code>cd editors/vscode\nbun install\nbun run build\n</code></pre> <p>Then install the <code>.vsix</code> file via VS Code: Extensions &gt; ... &gt; Install from VSIX.</p>"},{"location":"editor-support/#features-in-vs-code","title":"Features in VS Code","text":"<ul> <li>Syntax highlighting for <code>.lz</code> files</li> <li>All LSP features listed above</li> <li>Context-aware keyword argument completion inside <code>fetch()</code> and other builtins</li> <li>Hover tooltips on kwargs like <code>timeout:</code>, <code>method:</code>, etc.</li> </ul>"},{"location":"editor-support/#neovim","title":"Neovim","text":"<p>A Vim/Neovim plugin is included in the <code>editors/nvim/</code> directory with syntax highlighting, filetype detection, and comment settings.</p>"},{"location":"editor-support/#install-the-plugin","title":"Install the Plugin","text":"<p>With lazy.nvim:</p> <pre><code>{\n  dir = \"~/path/to/langz/editors/nvim\",\n  ft = \"langz\",\n}\n</code></pre> <p>With manual symlink:</p> <pre><code># Neovim\nln -s /path/to/langz/editors/nvim ~/.local/share/nvim/site/pack/langz/start/langz\n\n# Vim\nln -s /path/to/langz/editors/nvim ~/.vim/pack/langz/start/langz\n</code></pre>"},{"location":"editor-support/#lsp-setup-neovim","title":"LSP Setup (Neovim)","text":"<p>Neovim 0.11+ with LazyVim (recommended):</p> <p>Add a plugin spec to your LazyVim config (e.g. <code>~/.config/nvim/lua/plugins/langz.lua</code>):</p> <pre><code>return {\n  {\n    dir = \"~/path/to/langz/editors/nvim\",\n    ft = \"langz\",\n  },\n  {\n    \"neovim/nvim-lspconfig\",\n    opts = {\n      servers = {\n        langz = {\n          cmd = { \"langz\", \"lsp\" },\n          filetypes = { \"langz\" },\n          root_markers = { \".git\" },\n          mason = false,\n        },\n      },\n    },\n  },\n}\n</code></pre> <p>Neovim 0.11+ without LazyVim:</p> <pre><code>vim.lsp.config(\"langz\", {\n  cmd = { \"langz\", \"lsp\" },\n  filetypes = { \"langz\" },\n  root_markers = { \".git\" },\n})\nvim.lsp.enable(\"langz\")\n</code></pre> <p>Neovim &lt; 0.11 with <code>nvim-lspconfig</code>:</p> <pre><code>local configs = require(\"lspconfig.configs\")\nif not configs.langz then\n  configs.langz = {\n    default_config = {\n      cmd = { \"langz\", \"lsp\" },\n      filetypes = { \"langz\" },\n      root_dir = require(\"lspconfig\").util.find_git_ancestor,\n      single_file_support = true,\n    },\n  }\nend\nrequire(\"lspconfig\").langz.setup({})\n</code></pre>"},{"location":"editor-support/#lsp-setup-vim","title":"LSP Setup (Vim)","text":"<p>With vim-lsp:</p> <pre><code>if executable('langz')\n  au User lsp_setup call lsp#register_server(#{\n    \\ name: 'langz',\n    \\ cmd: ['langz', 'lsp'],\n    \\ allowlist: ['langz'],\n    \\ })\nendif\n</code></pre>"},{"location":"editor-support/#other-editors","title":"Other Editors","text":"<p>The LSP server can be used with any editor that supports the Language Server Protocol. Start the server with:</p> <pre><code>langz lsp\n</code></pre> <p>Configure your editor to use <code>langz lsp</code> as the language server for <code>.lz</code> files.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#deployment-script","title":"Deployment Script","text":"<pre><code>app = \"webapp\"\nversion = \"2.1.0\"\nplatform = os()\nhost = hostname()\n\nfn log(msg: str) {\n    print(\"[deploy] {msg}\")\n}\n\nlog(\"Deploying {app} v{version} on {host}\")\n\nmkdir(\"dist\")\nwrite(\"dist/manifest.txt\", \"app={app}\")\nappend(\"dist/manifest.txt\", \"version={version}\")\n\nenv_name = env(\"DEPLOY_ENV\") or \"staging\"\n\nmatch env_name {\n    \"production\" =&gt; log(\"PRODUCTION deploy\")\n    \"staging\"    =&gt; log(\"Staging deploy\")\n    _            =&gt; log(\"Unknown: {env_name}\")\n}\n\nlog(\"Done!\")\n</code></pre>"},{"location":"examples/#log-file-cleanup","title":"Log File Cleanup","text":"<pre><code>max_age = 7\ncount = 0\n\nfor f in glob(\"/var/log/app/*.log\") {\n    age = exec(\"find {f} -mtime +{max_age} -print\")\n    if age != \"\" {\n        rm(f)\n        count = count + 1\n    }\n}\n\nprint(\"Cleaned {count} old log files\")\n</code></pre>"},{"location":"examples/#health-check-with-retry","title":"Health Check with Retry","text":"<pre><code>fn check_health(url: str, max_retries: int) {\n    data = fetch(url, timeout: 5, retries: max_retries) or \"failed\"\n\n    if _status == 200 {\n        print(\"OK: {url}\")\n    } else {\n        print(\"FAIL: {url} (status {_status})\")\n        exit(1)\n    }\n}\n\ncheck_health(\"https://api.example.com/health\", 3)\ncheck_health(\"https://cdn.example.com/ping\", 2)\n</code></pre>"},{"location":"examples/#api-integration","title":"API Integration","text":"<pre><code>// Fetch user data and extract fields\nfetch(\"https://api.example.com/user/1\", timeout: 10)\n\nif _status == 200 {\n    name = json_get(_body, \".name\")\n    email = json_get(_body, \".email\")\n    print(\"User: {name} ({email})\")\n} else {\n    print(\"API error: {_status}\")\n}\n</code></pre>"},{"location":"examples/#system-info-report","title":"System Info Report","text":"<pre><code>fn report() {\n    _os = os()\n    _arch = arch()\n    host = hostname()\n    user = whoami()\n    ts = timestamp()\n\n    print(\"=== System Report ===\")\n    print(\"OS:       {_os}\")\n    print(\"Arch:     {_arch}\")\n    print(\"Host:     {host}\")\n    print(\"User:     {user}\")\n    print(\"Time:     {ts}\")\n\n    mkdir(\"reports\")\n    write(\"reports/system.txt\", \"os={_os} arch={_arch} host={host}\")\n}\n\nreport()\n</code></pre>"},{"location":"examples/#file-backup","title":"File Backup","text":"<pre><code>src = env(\"BACKUP_SRC\") or \"/etc/nginx\"\ndst = env(\"BACKUP_DST\") or \"/tmp/backups\"\ntoday = date()\n\nif is_dir(src) {\n    backup_dir = \"{dst}/{today}\"\n    mkdir(backup_dir)\n    bash {\n        cp -r \"$src\"/* \"$backup_dir\"/ 2&gt;/dev/null || true\n    }\n    print(\"Backed up {src} to {backup_dir}\")\n} else {\n    print(\"Source not found: {src}\")\n    exit(1)\n}\n</code></pre>"},{"location":"examples/#bash-escape-hatch","title":"Bash Escape Hatch","text":"<p>Use <code>bash { }</code> for shell-specific logic:</p> <pre><code>print(\"Checking system...\")\n\nbash {\n    if command -v docker &amp;&gt;/dev/null; then\n        docker_version=$(docker --version)\n        echo \"Docker: $docker_version\"\n    else\n        echo \"Docker not installed\"\n    fi\n}\n\nbash {\n    for f in /var/log/*.log; do\n        [ -f \"$f\" ] || continue\n        size=$(stat -f%z \"$f\" 2&gt;/dev/null || stat -c%s \"$f\" 2&gt;/dev/null)\n        echo \"  $f: ${size} bytes\"\n    done\n}\n</code></pre>"},{"location":"examples/#imports","title":"Imports","text":"<p>Split code into reusable modules:</p> <pre><code>// lib/logging.lz\nfn info(msg: str) {\n    print(\"[INFO] {msg}\")\n}\n\nfn error(msg: str) {\n    print(\"[ERROR] {msg}\")\n}\n</code></pre> <pre><code>// deploy.lz\nimport \"lib/logging.lz\"\n\ninfo(\"Starting deployment\")\nmkdir(\"dist\")\ninfo(\"Build directory ready\")\n</code></pre> <p>Run with <code>langz run deploy.lz</code> -- imports are resolved automatically. Circular imports are detected and reported as errors.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-source-go","title":"From Source (Go)","text":"<pre><code>go install github.com/tasnimzotder/langz/cmd/langz@latest\n</code></pre>"},{"location":"getting-started/#from-github-releases","title":"From GitHub Releases","text":"<p>Download the latest binary from GitHub Releases for your platform (linux/darwin, amd64/arm64).</p>"},{"location":"getting-started/#your-first-script","title":"Your First Script","text":"<p>Create a file called <code>hello.lz</code>:</p> <pre><code>name = \"World\"\nprint(\"Hello {name}!\")\n</code></pre>"},{"location":"getting-started/#compile-to-bash","title":"Compile to Bash","text":"<pre><code>langz build hello.lz\n</code></pre> <p>This generates <code>hello.sh</code>:</p> <pre><code>#!/bin/bash\nset -euo pipefail\n\nname=\"World\"\necho \"Hello ${name}!\"\n</code></pre>"},{"location":"getting-started/#run-directly","title":"Run Directly","text":"<pre><code>langz run hello.lz\n</code></pre> <p>This compiles and executes in one step. You can also omit the <code>run</code> subcommand:</p> <pre><code>langz hello.lz\n</code></pre>"},{"location":"getting-started/#shebang-support","title":"Shebang Support","text":"<p>Add a shebang line to make <code>.lz</code> files directly executable:</p> <pre><code>#!/usr/bin/env langz\nname = \"World\"\nprint(\"Hello {name}!\")\n</code></pre> <pre><code>chmod +x hello.lz\n./hello.lz\n</code></pre> <p>The shebang line is automatically skipped by the compiler.</p>"},{"location":"getting-started/#imports","title":"Imports","text":"<p>Split code across files using <code>import</code>:</p> <pre><code>// lib/helpers.lz\nfn greet(name: str) {\n    print(\"Hello {name}\")\n}\n</code></pre> <pre><code>// main.lz\nimport \"lib/helpers.lz\"\ngreet(\"world\")\n</code></pre> <p>Import paths are resolved relative to the importing file. Circular imports are detected and reported as errors.</p>"},{"location":"getting-started/#file-extension","title":"File Extension","text":"<p>LangZ files use the <code>.lz</code> extension.</p>"},{"location":"getting-started/#what-gets-generated","title":"What Gets Generated","text":"<p>Every LangZ script compiles to a Bash script with:</p> <ul> <li><code>#!/bin/bash</code> shebang</li> <li><code>set -euo pipefail</code> for safe defaults</li> <li>Proper variable quoting</li> <li>Standard shell idioms</li> </ul> <p>The generated Bash is readable and portable -- no runtime dependencies.</p>"},{"location":"internals/","title":"Internals","text":"<p>How LangZ works under the hood.</p>"},{"location":"internals/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>Source (.lz) \u2192 Lexer \u2192 Parser \u2192 AST \u2192 Import Resolution \u2192 Codegen \u2192 Bash (.sh)\n</code></pre> Stage Description Lexer Tokenizes source into tokens (identifiers, strings, operators, keywords). Skips shebang lines (<code>#!...</code>). Captures <code>bash { }</code> blocks as raw <code>BASH_CONTENT</code> tokens with brace-depth tracking. Emits <code>ILLEGAL</code> tokens for malformed input. Supports unicode identifiers Parser Recursive descent parser builds an Abstract Syntax Tree. Reports structured errors for invalid tokens. Supports <code>ParseAllErrors()</code> for multi-error reporting Import Resolution CLI walks the AST, finds <code>ImportStmt</code> nodes, reads/lexes/parses imported files, and prepends their statements. Detects circular imports via a visited set. Codegen never touches the filesystem Codegen Walks the AST and emits Bash code. <code>BashBlock</code> content is emitted verbatim. <code>ImportStmt</code> nodes are skipped (already resolved). Marks unhandled nodes with <code># error:</code> comments"},{"location":"internals/#project-structure","title":"Project Structure","text":"<pre><code>langz/\n\u251c\u2500\u2500 cmd/langz/              CLI entry point\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 ast/                AST node types\n\u2502   \u251c\u2500\u2500 lexer/              Tokenizer (tokens.go, lexer.go)\n\u2502   \u251c\u2500\u2500 parser/             Recursive descent parser\n\u2502   \u2502   \u251c\u2500\u2500 parser.go       Core parser, entry points\n\u2502   \u2502   \u251c\u2500\u2500 expressions.go  Expression parsing\n\u2502   \u2502   \u2514\u2500\u2500 statements.go   Statement parsing\n\u2502   \u251c\u2500\u2500 codegen/            Bash code generator\n\u2502   \u2502   \u251c\u2500\u2500 codegen.go      Core generator\n\u2502   \u2502   \u251c\u2500\u2500 expressions.go  Expression codegen\n\u2502   \u2502   \u251c\u2500\u2500 statements.go   Statement codegen\n\u2502   \u2502   \u251c\u2500\u2500 fetch.go        fetch() codegen (multi-line curl)\n\u2502   \u2502   \u2514\u2500\u2500 builtins/       Built-in function registry\n\u2502   \u2514\u2500\u2500 lsp/                Language Server Protocol\n\u251c\u2500\u2500 editors/vscode/         VS Code extension\n\u251c\u2500\u2500 test/integration/       End-to-end tests\n\u251c\u2500\u2500 examples/               Example .lz scripts\n\u2514\u2500\u2500 docs/                   Documentation (MkDocs)\n</code></pre>"},{"location":"internals/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"internals/#no-parser-generator","title":"No Parser Generator","text":"<p>The parser is hand-written recursive descent. This keeps dependencies minimal and makes the parser easy to extend with new syntax.</p>"},{"location":"internals/#two-codegen-function-types","title":"Two Codegen Function Types","text":"<ul> <li><code>ExprGen</code> -- generates quoted expressions (e.g. <code>\"$var\"</code>)</li> <li><code>RawValueGen</code> -- generates unquoted values (e.g. <code>var</code> for arithmetic)</li> </ul> <p>This distinction is critical for Bash correctness. Arithmetic contexts like <code>$((...))</code> need unquoted variable names, while most other contexts need quoted values.</p>"},{"location":"internals/#builtin-registry-pattern","title":"Builtin Registry Pattern","text":"<p>Built-in functions are registered in maps (<code>stmtBuiltins</code>, <code>exprBuiltins</code>) with a common handler signature. This makes adding new builtins a one-line change.</p>"},{"location":"internals/#statement-level-fetch","title":"Statement-Level Fetch","text":"<p><code>fetch()</code> can't be a simple expression builtin because it needs multi-line output (mktemp, curl, parse status, cleanup). It's intercepted at the codegen level in <code>genAssignment()</code> and <code>genFuncCallStmt()</code> before the normal builtin dispatch.</p>"},{"location":"internals/#convention-variables","title":"Convention Variables","text":"<p><code>fetch()</code> sets <code>_status</code>, <code>_body</code>, <code>_headers</code> as global variables. This avoids the need for structured return types while keeping the API simple.</p>"},{"location":"internals/#shebang-handling","title":"Shebang Handling","text":"<p>Shebang lines (<code>#!/usr/bin/env langz</code>) are skipped in the lexer, not the parser. This means all consumers (CLI, LSP, tests) get the right behavior without special-casing. The CLI also auto-detects <code>.lz</code> files as <code>argv[1]</code> so shebang execution works (<code>./script.lz</code>).</p>"},{"location":"internals/#bash-blocks","title":"Bash Blocks","text":"<p><code>bash { }</code> blocks use a special lexer mode. After the <code>BASH</code> keyword, the lexer switches to <code>readBashContent()</code> which tracks brace depth (depth=1 on entry, +1 on <code>{</code>, -1 on <code>}</code>), respects string literals and comments to avoid false matches, and returns the raw content as a single <code>BASH_CONTENT</code> token. The parser just wraps this into a <code>BashBlock</code> AST node, and codegen emits it verbatim.</p>"},{"location":"internals/#import-resolution-in-cli","title":"Import Resolution in CLI","text":"<p>Imports are resolved in the CLI, not in codegen. This keeps codegen pure (no filesystem access). The <code>resolveImports()</code> function walks the AST, finds <code>ImportStmt</code> nodes, reads/lexes/parses imported files, and prepends their statements. A <code>visited</code> set detects circular imports. This is essentially a pre-codegen AST rewriting pass.</p>"},{"location":"internals/#multi-error-reporting","title":"Multi-Error Reporting","text":"<p>The CLI uses <code>ParseAllErrors()</code> instead of <code>ParseWithErrors()</code> and displays all errors with source context (file:line:col, source line, ^ pointer). Errors are capped at 10 to avoid flooding the terminal.</p>"},{"location":"internals/#token-based-lsp","title":"Token-Based LSP","text":"<p>The LSP server uses token streams (not AST) for hover, completion, and definition. This avoids needing position tracking in the AST and keeps the LSP implementation simple and robust.</p> <p>The server caches tokenized output per document (<code>Server.tokens</code> map), populated on <code>didOpen</code>/<code>didChange</code> and evicted on <code>didClose</code>. This avoids re-tokenizing on every hover, completion, or diagnostic request.</p>"},{"location":"internals/#error-handling-architecture","title":"Error Handling Architecture","text":"<p>Errors are handled at each pipeline stage, forming layered protection:</p>"},{"location":"internals/#lexer-shebang-and-bash-blocks","title":"Lexer: Shebang and Bash Blocks","text":"<p>The lexer handles two special cases before normal tokenization:</p> <ul> <li>Shebang: If input starts with <code>#!</code>, the entire first line is skipped</li> <li>Bash blocks: After the <code>BASH</code> keyword, the lexer enters <code>readBashContent()</code> mode, tracking brace depth and respecting string/comment boundaries to capture raw content as a <code>BASH_CONTENT</code> token</li> </ul>"},{"location":"internals/#lexer-illegal-tokens","title":"Lexer: ILLEGAL Tokens","text":"<p>The lexer never silently skips input. Unknown characters and unterminated strings produce <code>ILLEGAL</code> tokens with descriptive values:</p> <ul> <li><code>\"unterminated string\"</code> -- when a string literal reaches EOF without a closing <code>\"</code></li> <li>The character itself (e.g. <code>\"@\"</code>) -- when the lexer encounters an unrecognized character</li> </ul>"},{"location":"internals/#parser-error-reporting","title":"Parser: Error Reporting","text":"<p>The parser converts <code>ILLEGAL</code> tokens and unexpected token types into structured <code>ParseError</code> values:</p> <ul> <li><code>ILLEGAL</code> tokens: the token's value becomes the error message (e.g. \"unterminated string\")</li> <li>Unknown tokens: <code>\"unexpected token: &lt;type&gt;\"</code> is reported</li> </ul> <p>Errors accumulate in <code>Parser.errors</code> and are returned by <code>ParseAllErrors()</code>. The parser continues past errors to report as many as possible.</p>"},{"location":"internals/#codegen-error-markers","title":"Codegen: Error Markers","text":"<p>Unhandled AST node types in <code>genStatement()</code> and <code>genExpr()</code> emit Bash comments like <code># error: unhandled statement type *ast.ExitCall</code>. The existing <code>findCodegenErrors()</code> function scans the generated output for these markers and returns them as structured errors.</p>"},{"location":"internals/#panic-recovery","title":"Panic Recovery","text":"<p>All public API entry points use <code>defer/recover</code>:</p> <ul> <li><code>Generate()</code> -- returns empty output with <code>\"internal error: ...\"</code> on panic</li> <li><code>ParseWithErrors()</code> / <code>ParseAllErrors()</code> -- returns partial AST with error on panic</li> <li>Every LSP handler -- uses a shared <code>recoverErr()</code> helper to convert panics to LSP errors, preventing server crashes</li> </ul>"},{"location":"internals/#unicode-support","title":"Unicode Support","text":"<p>The lexer operates on runes (not bytes) using <code>utf8.DecodeRuneInString()</code>. Identifiers can contain any Unicode letter (<code>unicode.IsLetter()</code>) or digit (<code>unicode.IsDigit()</code>), supporting non-ASCII variable names like <code>\u540d\u524d</code> or <code>caf\u00e9</code>.</p>"},{"location":"internals/#testing","title":"Testing","text":"<p>The project uses testify for assertions and gotestsum as test runner.</p> <pre><code># Run all tests\ngotestsum -- ./...\n\n# Run specific test\ngotestsum -- -run TestName ./path/\n\n# Run integration tests only\ngotestsum -- ./test/integration/\n</code></pre> <p>Test categories:</p> <ul> <li>Parser tests -- verify AST construction from source</li> <li>Codegen tests -- verify generated Bash from AST</li> <li>Integration tests -- compile LangZ to Bash, execute it, check output</li> <li>LSP tests -- verify diagnostics, hover, completion, signature help</li> </ul>"},{"location":"language/control-flow/","title":"Control Flow","text":""},{"location":"language/control-flow/#ifelse","title":"If/Else","text":"<pre><code>if status == \"ready\" {\n    print(\"go\")\n} else {\n    print(\"wait\")\n}\n</code></pre> <p>Conditions support <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> and logical operators <code>and</code>, <code>or</code>:</p> <pre><code>if port &gt; 1024 and is_file(\"config.json\") {\n    print(\"ready\")\n}\n</code></pre>"},{"location":"language/control-flow/#elif-else-if-chaining","title":"Elif (Else-If Chaining)","text":"<p>Chain multiple conditions without nesting:</p> <pre><code>env_name = env(\"ENV\") or \"dev\"\nif env_name == \"production\" {\n    print(\"PROD\")\n} else if env_name == \"staging\" {\n    print(\"STAGING\")\n} else {\n    print(\"DEV\")\n}\n</code></pre> <p>Generated Bash: <pre><code>if [ \"$env_name\" = \"production\" ]; then\n  echo \"PROD\"\nelif [ \"$env_name\" = \"staging\" ]; then\n  echo \"STAGING\"\nelse\n  echo \"DEV\"\nfi\n</code></pre></p>"},{"location":"language/control-flow/#for-loops","title":"For Loops","text":""},{"location":"language/control-flow/#iterate-over-a-list","title":"Iterate over a list","text":"<pre><code>items = [\"alpha\", \"beta\", \"gamma\"]\nfor item in items {\n    print(item)\n}\n</code></pre>"},{"location":"language/control-flow/#iterate-over-a-range","title":"Iterate over a range","text":"<pre><code>for i in range(1, 10) {\n    print(i)\n}\n</code></pre>"},{"location":"language/control-flow/#iterate-over-files","title":"Iterate over files","text":"<pre><code>for f in glob(\"*.log\") {\n    print(\"Found: {f}\")\n}\n</code></pre>"},{"location":"language/control-flow/#while-loops","title":"While Loops","text":"<pre><code>retries = 3\nwhile retries &gt; 0 {\n    result = exec(\"./deploy.sh\") or \"\"\n    if result != \"\" {\n        break\n    }\n    retries -= 1\n    sleep(1)\n}\n</code></pre>"},{"location":"language/control-flow/#match-pattern-matching","title":"Match (Pattern Matching)","text":"<p><code>match</code> compiles to Bash <code>case</code>/<code>esac</code>:</p> <pre><code>platform = os()\nmatch platform {\n    \"darwin\" =&gt; print(\"macOS\")\n    \"linux\"  =&gt; print(\"Linux\")\n    _        =&gt; print(\"unknown: {platform}\")\n}\n</code></pre> <p>Match arms can have block bodies:</p> <pre><code>match env(\"DEPLOY_ENV\") or \"dev\" {\n    \"production\" =&gt; {\n        print(\"PRODUCTION\")\n        exec(\"notify-slack.sh\")\n    }\n    \"staging\" =&gt; print(\"staging\")\n    _ =&gt; print(\"dev\")\n}\n</code></pre>"},{"location":"language/control-flow/#break-and-continue","title":"Break and Continue","text":"<p><code>break</code> exits a loop, <code>continue</code> skips to the next iteration:</p> <pre><code>for f in glob(\"*.txt\") {\n    content = read(f) or continue\n    print(content)\n}\n</code></pre>"},{"location":"language/control-flow/#raw-bash-blocks","title":"Raw Bash Blocks","text":"<p>For shell-specific logic without a LangZ equivalent, use <code>bash { }</code> to embed raw Bash:</p> <pre><code>bash {\n    set -euo pipefail\n    trap 'cleanup' EXIT\n}\n</code></pre> <p>Content is emitted verbatim into the generated script. Nested braces are handled correctly:</p> <pre><code>bash {\n    if command -v docker &amp;&gt;/dev/null; then\n        echo \"Docker is installed\"\n    else\n        echo \"Docker not found\"\n    fi\n}\n</code></pre> <p>You can mix bash blocks with regular LangZ code:</p> <pre><code>name = \"deploy\"\nbash { echo \"Running: $name\" }\nprint(\"Done with {name}\")\n</code></pre>"},{"location":"language/error-handling/","title":"Error Handling","text":"<p>LangZ uses the <code>or</code> keyword for error handling. When an expression fails, the fallback value is used instead.</p>"},{"location":"language/error-handling/#default-values","title":"Default Values","text":"<pre><code>name = env(\"APP_NAME\") or \"myapp\"\nconfig = read(\"config.json\") or \"{}\"\n</code></pre> <p>Generated Bash: <pre><code>name=\"${APP_NAME:-myapp}\"\n</code></pre></p>"},{"location":"language/error-handling/#exit-on-failure","title":"Exit on Failure","text":"<pre><code>data = read(\"required.json\") or exit(1)\n</code></pre>"},{"location":"language/error-handling/#skip-in-loops","title":"Skip in Loops","text":"<pre><code>for f in glob(\"*.json\") {\n    content = read(f) or continue\n    print(content)\n}\n</code></pre>"},{"location":"language/error-handling/#block-fallback","title":"Block Fallback","text":"<p>Use a block for multi-statement fallbacks:</p> <pre><code>result = exec(\"deploy.sh\") or {\n    print(\"deploy failed, using fallback\")\n    \"fallback_value\"\n}\n</code></pre>"},{"location":"language/error-handling/#fetch-error-handling","title":"Fetch Error Handling","text":"<p><code>fetch()</code> sets the <code>_status</code> convention variable, and supports <code>or</code> fallback:</p> <pre><code>// Fallback on HTTP error\ndata = fetch(\"https://api.example.com/data\") or \"unavailable\"\n\n// Check status explicitly\nfetch(\"https://api.example.com/health\")\nif _status != 200 {\n    print(\"Health check failed: {_status}\")\n    exit(1)\n}\n</code></pre>"},{"location":"language/error-handling/#how-it-works","title":"How It Works","text":"<p>LangZ generates <code>set -euo pipefail</code> by default, which means any command failure exits the script. The <code>or</code> keyword wraps expressions in error-handling patterns:</p> <ul> <li>env() uses Bash parameter defaults: <code>${VAR:-default}</code></li> <li>General expressions use <code>if cmd 2&gt;/dev/null; then ... else ... fi</code></li> <li>fetch() uses <code>|| true</code> to prevent <code>set -e</code> from killing the script, then checks <code>_status</code></li> </ul>"},{"location":"language/functions/","title":"Functions","text":""},{"location":"language/functions/#defining-functions","title":"Defining Functions","text":"<p>Use <code>fn</code> to define functions with typed parameters:</p> <pre><code>fn greet(name: str) {\n    print(\"Hello {name}\")\n}\n\ngreet(\"world\")\n</code></pre> <p>Generated Bash: <pre><code>greet() {\n  local name=\"$1\"\n  echo \"Hello ${name}\"\n}\ngreet \"world\"\n</code></pre></p>"},{"location":"language/functions/#return-values","title":"Return Values","text":"<p>Functions can return values with <code>-&gt; type</code> and <code>return</code>:</p> <pre><code>fn add(a: int, b: int) -&gt; int {\n    return a + b\n}\n\nresult = add(3, 5)\nprint(result)\n</code></pre>"},{"location":"language/functions/#default-parameter-values","title":"Default Parameter Values","text":"<p>Parameters can have defaults using <code>= value</code>:</p> <pre><code>fn deploy(target: str = \"staging\") {\n    print(\"Deploying to {target}\")\n}\n\ndeploy()          // uses \"staging\"\ndeploy(\"prod\")    // uses \"prod\"\n</code></pre> <p>Generated Bash: <pre><code>deploy() {\n  local target=\"${1:-staging}\"\n  echo \"Deploying to ${target}\"\n}\n</code></pre></p>"},{"location":"language/functions/#multiple-parameters","title":"Multiple Parameters","text":"<pre><code>fn deploy(app: str, env: str, version: str) {\n    print(\"Deploying {app} v{version} to {env}\")\n    mkdir(\"dist/{app}\")\n    write(\"dist/{app}/version.txt\", version)\n}\n</code></pre>"},{"location":"language/functions/#script-arguments","title":"Script Arguments","text":"<p>Access command-line arguments with <code>args()</code>:</p> <pre><code>for arg in args() {\n    print(\"arg: {arg}\")\n}\n</code></pre> <p>Generated Bash: <pre><code>for arg in \"$@\"; do\n  echo \"arg: ${arg}\"\ndone\n</code></pre></p>"},{"location":"language/networking/","title":"Networking","text":"<p>LangZ provides HTTP support via <code>fetch()</code> (backed by <code>curl</code>) and JSON parsing via <code>json_get()</code> (backed by <code>jq</code>).</p>"},{"location":"language/networking/#fetch","title":"fetch()","text":""},{"location":"language/networking/#simple-get","title":"Simple GET","text":"<pre><code>data = fetch(\"https://api.example.com/health\")\nprint(data)\n</code></pre>"},{"location":"language/networking/#post-with-options","title":"POST with Options","text":"<p><code>fetch()</code> supports keyword arguments for full HTTP control:</p> <pre><code>resp = fetch(\"https://api.example.com/users\",\n    method: \"POST\",\n    body: payload,\n    headers: {\"Content-Type\": \"application/json\"},\n    timeout: 10,\n    retries: 3\n)\n</code></pre>"},{"location":"language/networking/#keyword-arguments","title":"Keyword Arguments","text":"Kwarg Description Default <code>method:</code> HTTP method (GET, POST, PUT, PATCH, DELETE) GET <code>body:</code> Request body data none <code>headers:</code> Request headers as map none <code>timeout:</code> Max seconds to wait for response none <code>retries:</code> Number of retry attempts on failure none"},{"location":"language/networking/#convention-variables","title":"Convention Variables","text":"<p>Every <code>fetch()</code> call sets three convention variables:</p> Variable Description <code>_status</code> HTTP status code (e.g. <code>200</code>, <code>404</code>) <code>_body</code> Response body <code>_headers</code> Response headers <pre><code>fetch(\"https://api.example.com/users\")\n\nif _status == 200 {\n    print(\"OK: {_body}\")\n} else {\n    print(\"Failed with status {_status}\")\n}\n</code></pre> <p>Warning</p> <p>A second <code>fetch()</code> call overwrites <code>_status</code>, <code>_body</code>, and <code>_headers</code>. Save values to named variables if you need them across multiple requests.</p>"},{"location":"language/networking/#error-handling","title":"Error Handling","text":"<p>Use <code>or</code> for fallback values on failure:</p> <pre><code>data = fetch(\"https://api.example.com/data\") or \"unavailable\"\n</code></pre> <p>When <code>retries:</code> is set, the request is retried up to N times with a 1-second delay between attempts. Retries stop on a 2xx response.</p>"},{"location":"language/networking/#json_get","title":"json_get()","text":"<p>Extract values from JSON strings using jq path expressions:</p> <pre><code>data = fetch(\"https://api.example.com/user/1\")\nname = json_get(_body, \".name\")\ncity = json_get(_body, \".address.city\")\nprint(\"User: {name} from {city}\")\n</code></pre> <p>Note</p> <p><code>json_get()</code> requires <code>jq</code> to be installed on the target system.</p>"},{"location":"language/networking/#full-example","title":"Full Example","text":"<pre><code>// Create a user via API\npayload = read(\"user.json\")\nresp = fetch(\"https://api.example.com/users\",\n    method: \"POST\",\n    body: payload,\n    headers: {\"Content-Type\": \"application/json\"},\n    timeout: 30,\n    retries: 2\n)\n\nif _status == 201 {\n    user_id = json_get(_body, \".id\")\n    print(\"Created user: {user_id}\")\n} else {\n    print(\"Failed: HTTP {_status}\")\n    exit(1)\n}\n</code></pre>"},{"location":"language/variables/","title":"Variables &amp; Types","text":""},{"location":"language/variables/#assignment","title":"Assignment","text":"<p>Variables are assigned with <code>=</code>. No <code>let</code>, <code>var</code>, or <code>$</code> needed.</p> <pre><code>name = \"langz\"\nport = 8080\nverbose = true\n</code></pre> <p>Generated Bash: <pre><code>name=\"langz\"\nport=8080\nverbose=true\n</code></pre></p>"},{"location":"language/variables/#types","title":"Types","text":"<p>LangZ supports these value types:</p> Type Example Bash String <code>\"hello\"</code> <code>\"hello\"</code> Number <code>42</code> <code>42</code> Boolean <code>true</code> / <code>false</code> <code>true</code> / <code>false</code> List <code>[\"a\", \"b\", \"c\"]</code> <code>(\"a\" \"b\" \"c\")</code> Map <code>{host: \"localhost\"}</code> <code>varname_key=val</code>"},{"location":"language/variables/#string-interpolation","title":"String Interpolation","text":"<p>Use <code>{variable}</code> inside strings to interpolate values:</p> <pre><code>host = \"localhost\"\nport = 3000\nprint(\"Server at {host}:{port}\")\n</code></pre> <p>Generated Bash: <pre><code>echo \"Server at ${host}:${port}\"\n</code></pre></p>"},{"location":"language/variables/#lists","title":"Lists","text":"<pre><code>items = [\"alpha\", \"beta\", \"gamma\"]\n\nfor item in items {\n    print(item)\n}\n</code></pre>"},{"location":"language/variables/#maps","title":"Maps","text":"<p>Maps use <code>key: value</code> syntax. Keys can be identifiers or strings:</p> <pre><code>config = {host: \"localhost\", port: 8080}\nheaders = {\"Content-Type\": \"application/json\", \"Accept\": \"text/html\"}\n</code></pre> <p>String keys are useful when keys contain special characters like hyphens.</p>"},{"location":"language/variables/#indexing","title":"Indexing","text":"<p>Access array elements by index and map values by string key:</p> <pre><code>items = [\"alpha\", \"beta\", \"gamma\"]\nfirst = items[0]\nprint(first)\n\nconfig = {host: \"localhost\", port: \"8080\"}\nval = config[\"host\"]\nprint(val)\n</code></pre> <p>Index assignment:</p> <pre><code>items[1] = \"BETA\"\n</code></pre>"},{"location":"language/variables/#compound-assignment","title":"Compound Assignment","text":"<p>Shorthand operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code> for updating variables:</p> <pre><code>count = 0\ncount += 1\ntotal = 100\ntotal -= 10\n</code></pre> <p>Generated Bash: <pre><code>count=$((count + 1))\ntotal=$((total - 10))\n</code></pre></p>"},{"location":"language/variables/#arithmetic","title":"Arithmetic","text":"<p>Standard arithmetic operators work on numeric values:</p> <pre><code>a = 10\nb = 3\nsum = a + b\nproduct = a * b\nremainder = a % b\ncomplex = (a + b) * 2\n</code></pre> <p>Generated Bash: <pre><code>sum=$((a + b))\nproduct=$((a * b))\n</code></pre></p>"}]}